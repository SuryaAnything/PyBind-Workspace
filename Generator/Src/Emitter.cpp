#include "../Include/Emitter.hpp"
#include <fstream>
#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <filesystem>
namespace fs = std::filesystem;

void Emitter::Write(const std::string& lib_name, const std::vector<ClassInfo>& classes, const std::string& output_dir, const std::string& src_dir) {
    if (!fs::exists(output_dir)) fs::create_directory(output_dir);
    std::string filename = output_dir + "/bindings_" + lib_name + ".cpp";
    std::ofstream out(filename);

    out << "// AUTO-GENERATED BY C++ OVERSEER (V3-ROBUST)\n";
    out << "#include <pybind11/pybind11.h>\n";
    out << "#include <pybind11/stl.h>\n";
    out << "#include <pybind11/functional.h>\n";
    out << "#include <pybind11/operators.h>\n"; 

    std::unordered_set<std::string> includes;
    for (const auto& c : classes) includes.insert(c.source_file);
    for (const auto& inc : includes) out << "#include \"../" << src_dir << "/" << inc << "\"\n";
    
    out << "\nnamespace py = pybind11;\n\nPYBIND11_MODULE(" << lib_name << ", m) {\n";
    for (const auto& cls : classes) {
        // --- 1. Class Definition (With Inheritance) ---
        out << "    py::class_<" << cls.name;
        if (!cls.parent_name.empty()) {
            out << ", " << cls.parent_name; // Add Parent Class
        }
        out << ">(m, \"" << cls.name << "\")\n";
        
        // --- 2. Constructors ---
        bool has_ctor = false;
        for (const auto& m : cls.methods) {
            if (m.is_constructor) {
                has_ctor = true;
                out << "        .def(py::init<";
                for (size_t i = 0; i < m.args.size(); ++i) out << m.args[i] << (i < m.args.size()-1 ? ", " : "");
                out << ">())\n";
            }
        }
        if (!has_ctor) out << "        .def(py::init<>())\n";

        // --- 3. Methods (Overloads + Operators) ---
        std::unordered_map<std::string, int> method_counts;
        for (const auto& m : cls.methods) if (!m.is_constructor) method_counts[m.name]++;

        for (const auto& m : cls.methods) {
            if (m.is_constructor) continue;
            
            // Determine binding name: "func" or "__add__" (for operators)
            std::string bind_name = m.operator_name.empty() ? m.name : m.operator_name;

            if (m.is_static) {
                out << "        .def_static(\"" << bind_name << "\", &" << cls.name << "::" << m.name << ")\n";
            } else {
                if (method_counts[m.name] > 1) {
                    // Overload
                    out << "        .def(\"" << bind_name << "\", py::overload_cast<";
                    for (size_t i = 0; i < m.args.size(); ++i) out << m.args[i] << (i < m.args.size()-1 ? ", " : "");
                    out << ">(&" << cls.name << "::" << m.name;
                    if (m.is_const) out << ", py::const_";
                    out << "))\n";
                } else {
                    // Simple
                    out << "        .def(\"" << bind_name << "\", &" << cls.name << "::" << m.name << ")\n";
                }
            }
        }
        out << "    ;\n";
    }
    out << "}\n";
    std::cout << "  -> Generated: " << filename << "\n";
}